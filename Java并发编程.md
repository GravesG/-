### Volatile

> volatile两条实现原则

1. Lock前缀指令会引起处理器缓存回到内存
2. 一个处理器的缓存会写到内存会导致其他处理器的缓存无效





### Synchronized的三种表现形式

- 对于普通同步方法，锁的是当前实例对象
- 对于静态同步方法，锁的是当前类的Class对象
- 对于同步方法快，锁的是Synchronized括号里面配置的对象



代码块同步是使用**monitorenter**和**monitorexit**指令实现的

**monitorenter**指令实在编译后插入到同步代码块的开始位置。

**monitorexit**是插入到方法结束处和异常处。



### 对象头

Sychronized用的锁是存在对象头里面的。

如果对象是数组类型，，则虚拟机用3个字宽存储对象头，如果是为数组类型，则用两个**字宽**存储对象头。

在32位虚拟机中，1字宽等于4字节

![image-20200810200510827](C:\Users\guozetao\AppData\Roaming\Typora\typora-user-images\image-20200810200510827.png)



Mark Word的默认存储结构如图

![image-20200810200655467](C:\Users\guozetao\AppData\Roaming\Typora\typora-user-images\image-20200810200655467.png)

Mark Word可能的四种数据：

![image-20200810201039680](C:\Users\guozetao\AppData\Roaming\Typora\typora-user-images\image-20200810201039680.png)



在**64位**虚拟机下，Mark Word是64bit大小的，：





### 锁的级别与对比

无锁状态--》偏向锁状态--》轻量级锁状态--》重量级锁状态

**锁只可以升级，不可以降级。**



1. 偏向锁

   当一个线程访问同步代码块并获取锁的时候，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步的代码块的时候，不需要进行CAS操作来加锁和解锁。

   只需要测试一下==Mark Word==里是否存折指向当前线程的偏向锁。如果测试成功，表示已经获得了锁；如果测试失败，则需要再测试一下Mrak Wor中偏向锁标识是否设置成了1.如果没有设置，则采用CAS竞争锁；如果设置了，则尝试CAS将对象头的偏向锁指向当前线程。

   

2. 轻量级锁

   1. 轻量级锁加锁

   线程执行同步代码块之前，JVM会在当前线程的栈帧中创建用于存储锁记录得空间。将对象头中的Mark Word 复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换成指向锁的指针。如果成功则获取锁，如果失败，标识其他线程竞争锁，当前线程便尝试使用自旋锁来获取锁。

   2. 轻量级锁解锁

   解锁时，会使用原子的CAS操作将Mark Word替换回对象头，如果成功，测标表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

   

   一旦锁升级成了重量级锁，就再也回不到轻量级锁状态。

   